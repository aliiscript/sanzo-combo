import { isDeepStrictEqual } from 'node:util';
import { useReducer, useCallback, useMemo, useState } from 'react';
const reducer = (state, action) => {
    switch (action.type) {
        case 'focus-next-option': {
            const nextFocusedIndex = Math.min(state.size - 1, state.focusedIndex + 1);
            if (nextFocusedIndex === state.focusedIndex) {
                return state;
            }
            const needsToScroll = nextFocusedIndex >= state.visibleToIndex;
            if (!needsToScroll) {
                return {
                    ...state,
                    focusedIndex: nextFocusedIndex,
                };
            }
            const nextVisibleToIndex = Math.min(state.size, state.visibleToIndex + 1);
            const nextVisibleFromIndex = nextVisibleToIndex - state.visibleRowCount;
            return {
                ...state,
                focusedIndex: nextFocusedIndex,
                visibleFromIndex: nextVisibleFromIndex,
                visibleToIndex: nextVisibleToIndex,
            };
        }
        case 'focus-previous-option': {
            const nextFocusedIndex = Math.max(0, state.focusedIndex - 1);
            if (nextFocusedIndex === state.focusedIndex) {
                return state;
            }
            const needsToScroll = nextFocusedIndex <= state.visibleFromIndex;
            if (!needsToScroll) {
                return {
                    ...state,
                    focusedIndex: nextFocusedIndex,
                };
            }
            const nextVisibleFromIndex = Math.max(0, state.visibleFromIndex - 1);
            const nextVisibleToIndex = nextVisibleFromIndex + state.visibleRowCount;
            return {
                ...state,
                focusedIndex: nextFocusedIndex,
                visibleFromIndex: nextVisibleFromIndex,
                visibleToIndex: nextVisibleToIndex,
            };
        }
        case 'reset': {
            return action.state;
        }
        default: {
            return state;
        }
    }
};
const createDefaultState = ({ visibleRowCount: customVisibleRowCount, rows, }) => {
    const visibleRowCount = typeof customVisibleRowCount === 'number'
        ? Math.min(customVisibleRowCount, rows.length)
        : rows.length;
    return {
        visibleRowCount,
        size: rows.length,
        focusedIndex: 0,
        visibleFromIndex: 0,
        visibleToIndex: visibleRowCount,
        selectedIndex: undefined,
    };
};
export const useTableState = ({ visibleRowCount, rows }) => {
    const [state, dispatch] = useReducer(reducer, { visibleRowCount, rows }, createDefaultState);
    const [lastRows, setLastRows] = useState(rows);
    if (rows !== lastRows && !isDeepStrictEqual(rows, lastRows)) {
        dispatch({
            type: 'reset',
            state: createDefaultState({ visibleRowCount, rows }),
        });
        setLastRows(rows);
    }
    const focusNextRow = useCallback(() => {
        dispatch({
            type: 'focus-next-option',
        });
    }, []);
    const focusPreviousRow = useCallback(() => {
        dispatch({
            type: 'focus-previous-option',
        });
    }, []);
    const visibleRows = useMemo(() => {
        return rows
            .map((row, index) => ({
            data: row,
            index,
        }))
            .slice(state.visibleFromIndex, state.visibleToIndex);
    }, [rows, state.visibleFromIndex, state.visibleToIndex]);
    return {
        focusedIndex: state.focusedIndex,
        visibleFromIndex: state.visibleFromIndex,
        visibleToIndex: state.visibleToIndex,
        visibleRows,
        focusNextRow,
        focusPreviousRow,
    };
};
//# sourceMappingURL=use-table-state.js.map