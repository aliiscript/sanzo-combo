import { isDeepStrictEqual } from 'node:util';
import { useReducer, useCallback, useMemo, useState } from 'react';
const reducer = (state, action) => {
    switch (action.type) {
        case 'focus-next-option': {
            const nextFocusedIndex = Math.min(state.size - 1, state.focusedIndex + 1);
            if (nextFocusedIndex === state.focusedIndex) {
                return state;
            }
            const needsToScroll = nextFocusedIndex >= state.visibleToIndex;
            if (!needsToScroll) {
                return {
                    ...state,
                    focusedIndex: nextFocusedIndex,
                };
            }
            const nextVisibleToIndex = Math.min(state.size, state.visibleToIndex + 1);
            const nextVisibleFromIndex = nextVisibleToIndex - state.limit;
            return {
                ...state,
                focusedIndex: nextFocusedIndex,
                visibleFromIndex: nextVisibleFromIndex,
                visibleToIndex: nextVisibleToIndex,
            };
        }
        case 'focus-previous-option': {
            const nextFocusedIndex = Math.max(0, state.focusedIndex - 1);
            if (nextFocusedIndex === state.focusedIndex) {
                return state;
            }
            const needsToScroll = nextFocusedIndex <= state.visibleFromIndex;
            if (!needsToScroll) {
                return {
                    ...state,
                    focusedIndex: nextFocusedIndex,
                };
            }
            const nextVisibleFromIndex = Math.max(0, state.visibleFromIndex - 1);
            const nextVisibleToIndex = nextVisibleFromIndex + state.limit;
            return {
                ...state,
                focusedIndex: nextFocusedIndex,
                visibleFromIndex: nextVisibleFromIndex,
                visibleToIndex: nextVisibleToIndex,
            };
        }
        case 'select-focused-option':
            return {
                ...state,
                selectedIndex: state.focusedIndex,
            };
        case 'reset':
            return action.state;
        default:
            return state;
    }
};
const createDefaultState = ({ defaultLimit, defaultValue, options, }) => {
    const limit = typeof defaultLimit === 'number'
        ? Math.min(defaultLimit, options.length)
        : options.length;
    let selectedIndex;
    if (defaultValue) {
        selectedIndex = options.findIndex(option => {
            return option.value === defaultValue;
        });
    }
    return {
        limit,
        size: options.length,
        focusedIndex: 0,
        visibleFromIndex: 0,
        visibleToIndex: limit,
        selectedIndex,
    };
};
export const useSelectState = ({ defaultLimit, options, defaultValue, onChange, }) => {
    const [state, dispatch] = useReducer(reducer, { defaultLimit, defaultValue, options }, createDefaultState);
    const [lastOptions, setLastOptions] = useState(options);
    if (options !== lastOptions && !isDeepStrictEqual(options, lastOptions)) {
        dispatch({
            type: 'reset',
            state: createDefaultState({ defaultLimit, defaultValue, options }),
        });
        setLastOptions(options);
    }
    const focusNextOption = useCallback(() => {
        dispatch({
            type: 'focus-next-option',
        });
    }, []);
    const focusPreviousOption = useCallback(() => {
        dispatch({
            type: 'focus-previous-option',
        });
    }, []);
    const selectFocusedOption = useCallback(() => {
        dispatch({
            type: 'select-focused-option',
        });
        const option = options[state.focusedIndex];
        if (option) {
            onChange(option.value);
        }
    }, [options, state.focusedIndex]);
    const visibleOptions = useMemo(() => {
        return options
            .map((option, index) => ({
            ...option,
            index,
        }))
            .slice(state.visibleFromIndex, state.visibleToIndex);
    }, [options, state.visibleFromIndex, state.visibleToIndex]);
    return {
        focusedIndex: state.focusedIndex,
        visibleFromIndex: state.visibleFromIndex,
        visibleToIndex: state.visibleToIndex,
        selectedIndex: state.selectedIndex,
        visibleOptions,
        focusNextOption,
        focusPreviousOption,
        selectFocusedOption,
    };
};
//# sourceMappingURL=use-select-state.js.map